{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Scope This is a simple introduction to git . In this document, you will learn the fundamentals of version-control, and we'll cover the following skills create and setup a git project ( git init ) add and remove files ( git add , git rm ) check-in new changes ( git commit ) synchronize your local and remote copies of a project ( git pull , git push ) navigate the change history ( git log , git checkout ) working with multiple branches ( git branch , git merge ) resolve history conflict visualize the current state ( git status , git diff , git branch ) Of course,mMastering git goes well beyond the scope of the present document. In particular, the following topics will not be covered, but are no less important: collaboration (sharing a project with other persons) editing the history ( git rebase ) bisecting the history to look for bugs ( git bisect ) Additional resources Interactive git sandbox","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#scope","text":"This is a simple introduction to git . In this document, you will learn the fundamentals of version-control, and we'll cover the following skills create and setup a git project ( git init ) add and remove files ( git add , git rm ) check-in new changes ( git commit ) synchronize your local and remote copies of a project ( git pull , git push ) navigate the change history ( git log , git checkout ) working with multiple branches ( git branch , git merge ) resolve history conflict visualize the current state ( git status , git diff , git branch ) Of course,mMastering git goes well beyond the scope of the present document. In particular, the following topics will not be covered, but are no less important: collaboration (sharing a project with other persons) editing the history ( git rebase ) bisecting the history to look for bugs ( git bisect )","title":"Scope"},{"location":"#additional-resources","text":"Interactive git sandbox","title":"Additional resources"},{"location":"introduction/","text":"Introduction What is git ? git is a distributed version control system (VCS). A version control system enables management of change history for files. We will see about the \"distributed\" part later. Here's a representation of a simple (single branch) change history, where the arrow indicates time, each dot represents a different version (We will see more interesting examples later). Essentially, a VCS enables a workflow where change is incremental , reversible , and searchable . This drastically decreases the cost of making mistakes and breaking things, because it's easy to go back to a previous version ! When do you need it ? git is useful for any project you work on today and will still care about tommorow. It could be some source code, but it can also be a paper manuscript . This website itself is backed-up with git . git command line interface (CLI) There exist many GUIs (Graphical User Interfaces) for git, and most IDEs contain some kind of git interface, but the fundamental interface, and the only one that is available on servers typically accessed via ssh tunnels, is the command line, so that's what we will use here. The git CLI is composed of many sub-commands git <stuff> . In this tutorial we will go through the essential ones. I strongly recommend sticking to the CLI after you've mastered the basics, because it is by far the most portable way to use git: it is the only one available everywhere.","title":"Introduction"},{"location":"introduction/#introduction","text":"","title":"Introduction"},{"location":"introduction/#what-is-git","text":"git is a distributed version control system (VCS). A version control system enables management of change history for files. We will see about the \"distributed\" part later. Here's a representation of a simple (single branch) change history, where the arrow indicates time, each dot represents a different version (We will see more interesting examples later). Essentially, a VCS enables a workflow where change is incremental , reversible , and searchable . This drastically decreases the cost of making mistakes and breaking things, because it's easy to go back to a previous version !","title":"What is git ?"},{"location":"introduction/#when-do-you-need-it","text":"git is useful for any project you work on today and will still care about tommorow. It could be some source code, but it can also be a paper manuscript . This website itself is backed-up with git .","title":"When do you need it ?"},{"location":"introduction/#git-command-line-interface-cli","text":"There exist many GUIs (Graphical User Interfaces) for git, and most IDEs contain some kind of git interface, but the fundamental interface, and the only one that is available on servers typically accessed via ssh tunnels, is the command line, so that's what we will use here. The git CLI is composed of many sub-commands git <stuff> . In this tutorial we will go through the essential ones. I strongly recommend sticking to the CLI after you've mastered the basics, because it is by far the most portable way to use git: it is the only one available everywhere.","title":"git command line interface (CLI)"},{"location":"tutorial/","text":"Hands-on tutorial Requirements Info If you've used git on your current machine in the past, skip this section. make sure git is available on your system $ which git if not, follow official docs Next, you'll want to configure git globally $ git config --global user.name \"John Doe\" $ git config --global user.email johndoe@example.com Additional recommendations It also recommended to associate a terminal-based editor of your choice to git . For instance this is how you'd set nano $ git config --global core.editor nano This is because some advanced sub-commands require an editor, and its preferable to know that you are confortable with the one you get (otherwise it may default to vi , which is infamously hard to exit when you've never used it). It it recommended that to sign up on GitHub. Getting started (first commits) Info In this section we will create a dummy project from scratch . You can use an actual project of yours instead if you feel confortable to. Create a new project (or repository from now on) $ mkdir my-project $ cd my-project $ git init We now have an empty project: no files are currently being tracked , and we have no history. Let's introduce a very useful command that will help us visualize the current state of the repository : git status . Info While the output of git status calls is included in the page, it is strongly recommended to run these yourself in a terminal. git status On branch main No commits yet nothing to commit (create/copy files and use \"git add\" to track) Note We see that our history tree already contains a default branch named main . We explore the concept of branches in a following section. Now let's start by creating some file $ echo \"Hello world !\" > README.txt and see how this affects the state git status On branch main No commits yet Untracked files: (use \"git add <file>...\" to include in what will be committed) README.txt nothing added to commit but untracked files present (use \"git add\" to track) We see that the file we just created is currently untracked , meaning its evolution is not followed by git . The output of git status also contains a helpful hint at what to do next to start tracking it: $ git add README.txt git status On branch main No commits yet Changes to be committed: (use \"git rm --cached <file>...\" to unstage) new file: README.txt We see that README.txt is now being tracked by the system, but it is not commited yet, meaning we haven't created an actual version (or commit , from now on) in the history. So let's do just that $ git commit -m \"Add README.txt\" with -m , with associate a message to our commit. The message should be concise yet meaningful and describe the change that was performed. git status On branch main nothing to commit, working tree clean Hurray ! Now README.txt is being tracked by git and we have a history that should look something like this (hey, one has to start somewhere ) Note HEAD represents our current position in the history. It usually points to the latest commit. In the next section we will learn how to move it across the history tree. More interestingly, we can now visualize our brand new history with git log , which should output something like this commit 956206c5db49848047ef45161ed9e457dcb5f9a8 (HEAD -> main) Author: John Doe <johndoe@example.com> Date: Mon Nov 28 15:22:38 2022 +0100 Add README.txt There we see all our most recent commits (just one in this case). Note In addition to the rest of our metadata (author, date, commit message), each commit is uniquely identified by a hash ( 956206c5db49848047ef45161ed9e457dcb5f9a8 in the example above). This is an alpha-numeric string that is generated by a deterministic but chaotic algorithm, which outputs are very likely to be unique within a project. Excercise Repeat the last few steps: add new files to the index, and commit them TODO demonstrate how to modify already tracked files (into git add -u , git diff ) Now we should have a more detailed history Going back in time Info In this section we will learn how to navigate the history, i.e., visiting previous versions of the project using git checkout git checkout is the go-to command to change the position of HEAD on the history tree . Say we want to visualize our project as it was two commits ago. What we want is to displace HEAD as This can be done as a relative displacement $ git checkout HEAD~2 Alternatively, if we know the hash of the exact commit we want to visit, we can use absolute displacement. For instance $ git checkout 956206c5db49848047ef45161ed9e457dcb5f9a8 Note While visiting a commit that belongs to the past, we cannot commit new changes (time paradoxes are not allowed !) To get back to our initial state (visit the present ) of our main branch $ git chekcout main To get back to the previous position in history, a convenience, akin to cd - is $ git checkout - Using a remote reference Info In this section we learn how to synchronise a local copy with a distant remote using git pull and git push Using branches Info In this section we will learn how to use history branches , which are a central and powerful concept at the heart of most development workflows. Introdution to branches A branch can be thought of as an alternative timeline in which changes can be made without impacting the state of the main history. A branch may be used to develop a change (say a feature in your code, a section in your paper...), in isolation . Here's what a two-branch history may look like Notice that commits have been made to both branches since their last common ancestor commit. Indeed, branches allow you to work on multiple aspects of your projects in parallel. This is also what enables collaborating on a project with other persons. It is best to keep each branch dedicated to a very specific task to avoid overlaps (conflicts). Again, HEAD indicates our current position on the history tree. It can only point to one branch at a time. Visualizing the current branch on the command line is done like so $ git branch * main feature where the * char indicates the current position of HEAD . As you may have guessed, the natural way to switch branch is to use git checkout $ git checkout feature Creating a new branch To create a new branch, and position HEAD onto it $ git branch feature_2 $ git checkout feature_2 Alternatively, this can be accomplished in one command with $ git checkout -b feature_2 where -b means (you guessed it) \"branch\". Merging back Reconcilling parallel histories is called merging . $ git checkout main $ git pull $ git merge --no-ff feature","title":"Hands-on tutorial"},{"location":"tutorial/#hands-on-tutorial","text":"","title":"Hands-on tutorial"},{"location":"tutorial/#requirements","text":"Info If you've used git on your current machine in the past, skip this section. make sure git is available on your system $ which git if not, follow official docs Next, you'll want to configure git globally $ git config --global user.name \"John Doe\" $ git config --global user.email johndoe@example.com","title":"Requirements"},{"location":"tutorial/#additional-recommendations","text":"It also recommended to associate a terminal-based editor of your choice to git . For instance this is how you'd set nano $ git config --global core.editor nano This is because some advanced sub-commands require an editor, and its preferable to know that you are confortable with the one you get (otherwise it may default to vi , which is infamously hard to exit when you've never used it). It it recommended that to sign up on GitHub.","title":"Additional recommendations"},{"location":"tutorial/#getting-started-first-commits","text":"Info In this section we will create a dummy project from scratch . You can use an actual project of yours instead if you feel confortable to. Create a new project (or repository from now on) $ mkdir my-project $ cd my-project $ git init We now have an empty project: no files are currently being tracked , and we have no history. Let's introduce a very useful command that will help us visualize the current state of the repository : git status . Info While the output of git status calls is included in the page, it is strongly recommended to run these yourself in a terminal. git status On branch main No commits yet nothing to commit (create/copy files and use \"git add\" to track) Note We see that our history tree already contains a default branch named main . We explore the concept of branches in a following section. Now let's start by creating some file $ echo \"Hello world !\" > README.txt and see how this affects the state git status On branch main No commits yet Untracked files: (use \"git add <file>...\" to include in what will be committed) README.txt nothing added to commit but untracked files present (use \"git add\" to track) We see that the file we just created is currently untracked , meaning its evolution is not followed by git . The output of git status also contains a helpful hint at what to do next to start tracking it: $ git add README.txt git status On branch main No commits yet Changes to be committed: (use \"git rm --cached <file>...\" to unstage) new file: README.txt We see that README.txt is now being tracked by the system, but it is not commited yet, meaning we haven't created an actual version (or commit , from now on) in the history. So let's do just that $ git commit -m \"Add README.txt\" with -m , with associate a message to our commit. The message should be concise yet meaningful and describe the change that was performed. git status On branch main nothing to commit, working tree clean Hurray ! Now README.txt is being tracked by git and we have a history that should look something like this (hey, one has to start somewhere ) Note HEAD represents our current position in the history. It usually points to the latest commit. In the next section we will learn how to move it across the history tree. More interestingly, we can now visualize our brand new history with git log , which should output something like this commit 956206c5db49848047ef45161ed9e457dcb5f9a8 (HEAD -> main) Author: John Doe <johndoe@example.com> Date: Mon Nov 28 15:22:38 2022 +0100 Add README.txt There we see all our most recent commits (just one in this case). Note In addition to the rest of our metadata (author, date, commit message), each commit is uniquely identified by a hash ( 956206c5db49848047ef45161ed9e457dcb5f9a8 in the example above). This is an alpha-numeric string that is generated by a deterministic but chaotic algorithm, which outputs are very likely to be unique within a project. Excercise Repeat the last few steps: add new files to the index, and commit them TODO demonstrate how to modify already tracked files (into git add -u , git diff ) Now we should have a more detailed history","title":"Getting started (first commits)"},{"location":"tutorial/#going-back-in-time","text":"Info In this section we will learn how to navigate the history, i.e., visiting previous versions of the project using git checkout git checkout is the go-to command to change the position of HEAD on the history tree . Say we want to visualize our project as it was two commits ago. What we want is to displace HEAD as This can be done as a relative displacement $ git checkout HEAD~2 Alternatively, if we know the hash of the exact commit we want to visit, we can use absolute displacement. For instance $ git checkout 956206c5db49848047ef45161ed9e457dcb5f9a8 Note While visiting a commit that belongs to the past, we cannot commit new changes (time paradoxes are not allowed !) To get back to our initial state (visit the present ) of our main branch $ git chekcout main To get back to the previous position in history, a convenience, akin to cd - is $ git checkout -","title":"Going back in time"},{"location":"tutorial/#using-a-remote-reference","text":"Info In this section we learn how to synchronise a local copy with a distant remote using git pull and git push","title":"Using a remote reference"},{"location":"tutorial/#using-branches","text":"Info In this section we will learn how to use history branches , which are a central and powerful concept at the heart of most development workflows.","title":"Using branches"},{"location":"tutorial/#introdution-to-branches","text":"A branch can be thought of as an alternative timeline in which changes can be made without impacting the state of the main history. A branch may be used to develop a change (say a feature in your code, a section in your paper...), in isolation . Here's what a two-branch history may look like Notice that commits have been made to both branches since their last common ancestor commit. Indeed, branches allow you to work on multiple aspects of your projects in parallel. This is also what enables collaborating on a project with other persons. It is best to keep each branch dedicated to a very specific task to avoid overlaps (conflicts). Again, HEAD indicates our current position on the history tree. It can only point to one branch at a time. Visualizing the current branch on the command line is done like so $ git branch * main feature where the * char indicates the current position of HEAD . As you may have guessed, the natural way to switch branch is to use git checkout $ git checkout feature","title":"Introdution to branches"},{"location":"tutorial/#creating-a-new-branch","text":"To create a new branch, and position HEAD onto it $ git branch feature_2 $ git checkout feature_2 Alternatively, this can be accomplished in one command with $ git checkout -b feature_2 where -b means (you guessed it) \"branch\".","title":"Creating a new branch"},{"location":"tutorial/#merging-back","text":"Reconcilling parallel histories is called merging . $ git checkout main $ git pull $ git merge --no-ff feature","title":"Merging back"}]}